#-----------------------------------------------------------------------------
# Name:        etterWrapperUtils.py
#
# Purpose:     This module is a wrapper program of the network tool 'ettercap'
#              which help the user to automate build the ettercap filter, then
#              compile the filter to apply it on APR spoofing /Mitm attack.
#
# Author:      Yuancheng Liu
#
# Created:     2024/01/07
# Version:     v_0.1
# Copyright:   Copyright (c) 2023 LiuYuancheng
# License:     MIT License
#-----------------------------------------------------------------------------

import threading
import time
import subprocess
from queue import Queue

MAX_CMD_QUEUE_SIZE = 100

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
class CmdRunner(threading.Thread):
    """ Command runner module to run a command immediately or store in the cmd 
        queue the run parallel with the parent thread.
    """
    def __init__(self, maxQsz=MAX_CMD_QUEUE_SIZE, rstDetailFlg=False):
        threading.Thread.__init__(self)
        self.cmdQueue = Queue(maxQsz)
        self.detailFlg = rstDetailFlg
        self.terminate = False

    #-----------------------------------------------------------------------------
    def run(self):
        print("Command Runner parallel cmd execution loop started.")
        while not self.terminate:
            if not self.cmdQueue.empty():
                cmdStr = self.cmdQueue.get()
                print("Parallel run cmdStr:", cmdStr)
                self.runCmd(cmdStr, detailFlg=self.detailFlg)
            time.sleep(0.1)
        print("Command Runner loop finished.")

    #-----------------------------------------------------------------------------
    def runCmdParallel(self, cmdStr):
        """ Add a command in the paralled execution queue."""
        if not self.cmdQueue.full():
            self.cmdQueue.put(cmdStr)
        else:
            print("Cmd queue is full, cannot add cmdStr:", cmdStr)

    #-----------------------------------------------------------------------------
    def runCmd(self, cmdStr, detailFlg=False):
        """ Run a command and collect the result on the victim host.
            Args:
                cmdStr (str): command string.
                detailFlg (bool, optional): flag to identify whether to show/return 
                    the execution detail. Defaults to False.
            Returns:
                str: return the command execution result, else return execution 
                    str 'success'/'fail'/'error'
        """
        if cmdStr:
            try:
                result = subprocess.check_output(str(cmdStr), 
                                                stderr=subprocess.STDOUT, 
                                                shell=True)
                print(result)
                return result if detailFlg else 'success'
            except Exception as err:
                print("Rum cmd error: %s" %str(err))
                return str(err) if detailFlg else 'fail'
        else:
            return 'error'

    #-----------------------------------------------------------------------------
    def stop(self):
        self.terminate = True

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
def buildtoTgtDropperCode(ipaddress, port, protocal='TCP'):
    ipaddr = str(ipaddress)
    port = str(port)
    protocal = str(protocal)
    content = """
    if (ip.proto == %s && tcp.dst == %s && ip.dst == '%s') {
        # block the traffic send to the destination.
        drop();
        msg("Drop the packet to the target.\\n");
    }""" % (protocal, port, ipaddr)
    return content

#-----------------------------------------------------------------------------
def buildFromTgtDropperCode(ipaddress, port, protocal='TCP'):
    ipaddr = str(ipaddress)
    port = str(port)
    protocal = str(protocal)
    content = """
    if (ip.proto == %s && tcp.dst == %s && ip.src == '%s') {
        # block the traffic send from the destination.
        drop();
        msg("Drop the packet to the target.\\n");
    }""" % (protocal, port, ipaddr)
    return content

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
def testCase(mode):
    if mode == 0:
        runner = CmdRunner(rstDetailFlg=True)
        runner.start()
        runner.runCmd('dir')
        runner.runCmdParallel('ping google.com')
        time.sleep(10)
        runner.stop()
    elif mode == 1:
        dropStr = buildtoTgtDropperCode('127.0.0.1',port=502)
        print(dropStr)

if __name__ == '__main__':
    testCase(1)
