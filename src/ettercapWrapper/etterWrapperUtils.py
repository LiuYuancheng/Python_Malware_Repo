#-----------------------------------------------------------------------------
# Name:        ettercapWrapperUtils.py
#
# Purpose:     This module is a wrapper program of the network tool 'ettercap'
#              which help the user to automate build the ettercap filter, then
#              compile the filter to apply it on APR spoofing /Mitm attack.
#
# Author:      Yuancheng Liu
#
# Created:     2024/01/07
# Version:     v_0.1
# Copyright:   
# License:     
#-----------------------------------------------------------------------------

import threading
import time
import subprocess
from queue import Queue

MAX_CMD_QUEUE_SIZE = 100

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
class CmdRunner(threading.Thread):
    """ Command runner module to run the command immediately or parallel with 
        its parent thread.
    """
    def __init__(self, maxQsz=MAX_CMD_QUEUE_SIZE, rstDetailFlg=False):
        threading.Thread.__init__(self)
        self.cmdQueue = Queue(maxQsz)
        self.detailFlg = rstDetailFlg
        self.terminate = False

    #-----------------------------------------------------------------------------
    def run(self):
        print("Command Runner parallel cmd execution loop started.")
        while not self.terminate:
            if not self.cmdQueue.empty():
                cmdStr = self.cmdQueue.get()
                print("Parallel run cmdStr:", cmdStr)
                self.runCmd(cmdStr, detailFlg=self.detailFlg)
            time.sleep(0.1)
        print("Command Runner loop finished.")

    #-----------------------------------------------------------------------------
    def runCmdParallel(self, cmdStr):
        """ Add a command in the paralled execution queue.
        """
        if not self.cmdQueue.full():
            self.cmdQueue.put(cmdStr)
        else:
            print("Cmd queue is full, cannot add cmdStr:", cmdStr)

    #-----------------------------------------------------------------------------
    def runCmd(self, cmdStr, detailFlg=False):
        """ Run a command and collect the result on the victim host.
        Args:
            returnType (str): if == 'detail' return the command execution result, 
                        else return execution success/fail
            cmdStr (str):  command string.
        """
        if cmdStr:
            try:
                result = subprocess.check_output(str(cmdStr), 
                                                stderr=subprocess.STDOUT, 
                                                shell=True)
                print(result)
                return result if detailFlg else 'success'
            except Exception as err:
                print("Rum cmd error: %s" %str(err))
                return str(err) if detailFlg else 'fail'
        else:
            return 'error'

    #-----------------------------------------------------------------------------
    def stop(self):
        self.terminate = True

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
def main():
    runner = CmdRunner(rstDetailFlg=True)
    runner.start()
    runner.runCmd('dir')
    runner.runCmdParallel('ping google.com')
    time.sleep(10)
    runner.stop()

if __name__ == '__main__':
    main()
