# Python Process Watchdog 

![](logo.png)

**Project Design Purpose** : During the cyber exercise we found as a red team, the injected malware or attack launching program can easy be stopped by the blue team or defense program via killing the process / deleting the file. We want to create a watchdog program which can bind to the target-program then monitor and protect the target-program's execution state : 

- If the targe program is closed or process killed , restart a new individual process to run the program.
- If the target program file is deleted, recover the program from backup and run the program. 

The watchdog can not only used in the cyber exercise red teaming but also in the field of protecting the normal service program (to avoid people killed the service accidently), research of malware action detection. The user can bind the watchdog to a single program to make it protect itself or hook several program with watchdog to build a protection chain to make the programs auto protect each other.

[TOC]

------

### Introduction 

We want to provide a python program execution protection watchdog library which people can easily used to bind in their program to avoid the program execution killed by other people or software. The watchdog will also provide the program recover function so even the protect program is deleted, the watchdog can recover the protect target then re-execute it. The overview work flow of the watchdog lib is shown below : 

![](../../doc/img/watchdog/overview.png)

Version : `v1.0.1`

**Background information (watch dog)** 

> A watchdog in the context of computer programs typically refers to a mechanism or a piece of software designed to monitor the execution of another program or system and take action if it detects certain issues or anomalies. The purpose of a watchdog is to ensure the continued and reliable operation of the monitored system.
>
> Here's how a typical watchdog mechanism works:
>
> 1. **Monitoring :**The watchdog monitors the behavior or status of a specific program or system.
> 2. **Timeouts :** The watchdog sets predefined timeouts. If the monitored program/system doesn't report back or complete a specific task within the expected timeframe, the watchdog assumes that something might be wrong.
> 3. **Action : **When a timeout or an issue is detected, the watchdog takes predefined actions. These actions can include restarting the monitored program, triggering an alarm, logging the issue for analysis, or even shutting down the entire system to prevent further damage.
> 4. **Health Checking :** In addition to timeouts, watchdogs may perform health checks on the monitored system. If the system's health falls below a certain threshold, the watchdog can trigger corrective actions.

##### Self Protection Demo 

Below demo shows how a program bind with the watchdog can protect its self to avoid being killed by user. Even user kills the program and deleted the program itself, it will recover it self and continuous execution . [View the full domo on YouTube](https://www.youtube.com/watch?v=coAn714g6Ok)

![](../../doc/img/watchdog/watchdog1.gif)

##### Protection Chain Demo

Below demo shows how programs bind with watchdog to build a protect chain to protect each other, so no mater the user kill how many program is the chain,  if there is more than one program is running, all the programs in the chain will be recover in the end. [View the full domo on YouTube](https://youtu.be/L-utChNhLBs?si=bAm2zyx19QtRsf_m)

![](../../doc/img/watchdog/watchdog2.gif)

The protection watchdogs can also use in embedded systems, critical infrastructure, servers, and other environments where continuous operation is crucial to help prevent issues like software freezes, crashes, or other unexpected failures from causing prolonged downtime. 



------

### Program Design

The program protection watchdog will run in sub-thread parallel with the main hooked program thread. It will monitor the protect target's process, if the target process is stopped, it will start a new individual process to run the target. For self protection, the watchdog will start a twin "shadow" watchdog running in background individual process, the program's watch dog will protect the shadow watch dog and the shadow one will protect the main program ( to build a protection dead lock ) . The program work flow diagram is shown below : 

![](../../doc/img/watchdog/workflow.png)

##### 1. Important Files 

Except the program, there are 2 related files watchdog will also keep : 

**Process ID record file** : 

- A text format history record file.
- The record file is used to help the watch dog to recovery protection, assume watchdog is protecting a program-A, if we kill watchdog and restart it, it will continuous monitor the current running program-A instead execute a new program-A.
- If the user want to build a protect chain, they don't need to keep several record file, link all the watch dog to one record file then the watchdog can protect each other.
- If the watchdog detect the record file is missing, it will start to create a new record file based on its current stored information. 

**Target Recover File:** 

- A zip file content all the target program
- If the user want the target program can be recovered when the program is delete, compress the target program's all files in a zip file and set the watchdog's backup file path, the watchdog will unzip the file and recover the target if some file is missiong. 

##### 2. Watchdog Internal Information 

Each watchdog will contents below information : 

- **Target program path** :  The protect target program / software path, the watch dog will check the program in its every clock cycle, if the file not exist ( delete by some one ), the watch dog will try to recover all the related files from its backup storage.
- **Target execution detail** : The steps / command / parameter to execute the target program. Once the target program is stopped, the watchdog will follow the details to re-execute the target.
- **Self Idx and Process ID** : The own process ID will be stored in the process record file based on the index for other watchdog to use to protect it. 
- **Target Idx and Process ID**: The protected target's  process ID and the idx in record file. If the process with the ID is not exist, the watchdog will re-execute the target program and record the new ID in the record file's idx position.
- **Record file path** : The record file's path. 
- **Recover file path** : The zipped targets program file path for recovery. 

##### 3. Protection Chain Build

To build a protect chain, the user can use peer to peer protection config ( each peer share one record file) to build the protection ring or make several watchdogs to share one record file to build a hub sharp protection chain. 

![](../../doc/img/watchdog/protectChain.png)

The logic is this, the watch dog will try to protect the program which share the same record file with it ( if it has the Target execution detail in its record ) . The beauty of this design is its flexibility and automation.  For example if we want to add a watch dog in the exist watchdog protection chain, just deploy the new watchdog's execution detail in any **ONE** of the watchdog's Target execution detail list, then point the new watchdog's record file to the chain's shared record file. Then the new watchdog will be protected by the chain, if you also add any one of the watchdog's execution detail in the new watch dog, the new watch dog will also protect the chain. 



------

### Protect Chain Work Progress Example

In this example we will show how to add watchdog in a protect chain

Below is an record file example of small watchdog chain ( 2 watchdogs protect each other share one record file ), malware0's own Idx is 0 and malware1's own Idx is 1:

```
# An example of the protection record
{
    'path': C:\\xxx\\malware0.py.
    'execution': 'python C:\\xxx\\malware0.py',  
    'backup': 'C:\\xxxx\\malware0.zip', 
    'rcdIdx': 0 # configured id in record file.
}
{
    'path': C:\\xxx\\malware1.py.
    'execution': 'python C:\\xxx\\malware1.py',  
    'backup': 'C:\\xxxx\\malware1.zip', 
    'rcdIdx': 1 # configured id in record file.
}
```

Now I want to add malware 2 in the chain, I just point the malware3(with watchdog)'s record path to the same record file. (malware3's own idx is 2) after I run the malware3, It will do below action: 

**Step 1** : Load malware1 and malware2 execution information into it. 

**Step 2** : As the malware3 didn't file its own record (rcdIdx==3) in the record file. it append its own execution details in the record file. And the new record file will be changed to below : 

```
{
    'path': C:\\xxx\\malware0.py.
    'execution': 'python C:\\xxx\\malware0.py',  
    'backup': 'C:\\xxxx\\malware0.zip', 
    'processID': 14332,
    'rcdIdx': 0 
}
{
    'path': C:\\xxx\\malware1.py.
    'execution': 'python C:\\xxx\\malware1.py',  
    'backup': 'C:\\xxxx\\malware1.zip',
    'processID': 36602,
    'rcdIdx': 1
}
{
    'path': C:\\xxx\\malware3.py.
    'execution': 'python C:\\xxx\\malware3.py',  
    'backup': 'C:\\xxxx\\malware3.zip', 
    'processID': 5002,
    'rcdIdx': 3
}
```

**Step 3** : When the malware0 or malware1 do the checking, they will also load the malware3's new execution detail into their memory. Now if we stop malware 2, malware0 or malware1 will auto re-execute malware2. 

Now if we kill malware 2 and malware 0 , and delete the record file. Only left malware1 running, in the next malware execution clock, it will rebuild the record file, and based on its current state, it need to run 2 malware. So the malware 1 will restart malware0 and malware2. Before malware0 and malware2 run the watchdog clock, the rebuild record file will be below: 

```
{
    'path': C:\\xxx\\malware0.py.
    'execution': 'python C:\\xxx\\malware0.py',  
    'backup': 'C:\\xxxx\\malware0.zip',
    'processID': 14332,
    'rcdIdx': 0 
}
{
    'path': C:\\xxx\\malware1.py.
    'execution': 'python C:\\xxx\\malware1.py',  
    'backup': 'C:\\xxxx\\malware1.zip',
    'processID': 11002,
    'rcdIdx': 1 # configured id in record file.
}
{
    'path': C:\\xxx\\malware3.py.
    'execution': 'python C:\\xxx\\malware3.py',  
    'backup': 'C:\\xxxx\\malware3.zip', 
    'processID': 2337,
    'rcdIdx': 3 
}
```

The the protect chain has been recovered 

So unless the user can kill all the watchdogs at the same time, if any one of the watch dog is not killed, the whole protection chain will recovery automatically. It we set the watchdog clock frequency to very high, it will be hardly for use to stop the protection chain manually. 



------





