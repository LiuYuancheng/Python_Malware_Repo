#!/usr/bin/python
#-----------------------------------------------------------------------------
# Name:        processWatch.py
#
# Purpose:     This module is used to protect a program's execution to avoid the 
#              user to stop it via close UI/exe-terminal or kill process. It will 
#              create an independent twin process to form a dead loop protection 
#              algorithm same as the malware. 
#
# Author:      Yuancheng Liu
#
# Version:     v_1.0.1
# Created:     2023/09/29
# Copyright:   Copyright (c) 2023 LiuYuancheng
# License:     MIT License  
#-----------------------------------------------------------------------------
""" Program Design : 
    Assume we have 2 python program P(A) and P(B) both hook with the watchdog. P(A)
    will keep checking the program running under P(B) if P(B) not exist P(A) will 
    execute the program again and update its new P(B) record. For P(B) the function
    is same, so unless the user kill P(A) and P(B) exactly at the same time, 
    otherwise the protected program will keep running.
"""

import os
import time
import psutil
import subprocess
import zipfile
import threading

DEFAULT_WAIT = 1 # default wait time.

TGT_PATH_KEY = 'path'
TGT_EXE_KEY = 'execution'
TGT_BACK_KEY = 'backup'
TGT_RIDX_KEY = 'rcdIdx'

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
class processWatchdog(threading.Thread):
    
    def __init__(self, targetInfo, rcdPath, idx=0, interval=5) -> None:
        
        """ Init example: protector = processWatchdog(<targetInfo dict>, <record file path>,
                                                idx=<0 or 1>, checkInterval)
        Args:
            targetInfo (dict): watchdog target information dictionary
                example :
                     targetInfo = {
                        'path': 'C:\\User\\test\test.py'                # target file path.
                        'execution': 'python3 C:\\User\\test\test.py'   # target file exeuction cmd
                        'backup': 'C:\\User\\test\test.zip'             # target program zip file
                        'rcdIdx': 0                                     # configured id in record file.
                    }
            rcdPath (str): process ID record file path.
            idx (int, optional): self id idx in the record file. Defaults to 0.
            interval (int, optional): Interval to check the protect process ID (sec). 
                        Defaults to 5 sec.
        """
        threading.Thread.__init__(self)
        self.tgtInfo = targetInfo
        self.ownPid = os.getpid()
        self.ownPIdx = idx
        self.tgtPid = -1
        self.rcdFile = rcdPath
        self.checkInterval = interval
        self.termate = False
        print("Watchdog init finished.")

#-----------------------------------------------------------------------------
    def run(self):
        # delay x second to want parent program finish init.
        time.sleep(DEFAULT_WAIT)
        print("Start to run the process protector.")
        while not self.termate:
            self.checkProtectTarget()
            time.sleep(self.checkInterval)

#-----------------------------------------------------------------------------
    def checkProtectTarget(self, autoRestart=True):
        """ Load the protected program's process ID from record file, then check
            whether the program is running.
        """
        if os.path.exists(self.rcdFile):
            try:
                with open(self.rcdFile, 'r') as fh:
                    pids = str(fh.readline()).strip()
                    idlist = pids.split(';')
                    idx = self.tgtInfo[TGT_RIDX_KEY]
                    self.tgtPid = int(idlist[idx])
                if psutil.pid_exists(self.tgtPid):
                    print("Protect target running.")
                    return True
            except Exception as err:
                print("Exception to check the : %s" % str(err))
    
        if autoRestart:
            print("Auto resetart the target program...")
            if not os.path.exists(self.tgtInfo[TGT_PATH_KEY]):
                print("Redeploy program from backup")
                self.redeployTgtProgram()
            self.restartTgtProgram()
            return True
        else:
            print("Target program is killed")
            return False

#-----------------------------------------------------------------------------
    def redeployTgtProgram(self):
        if os.path.exists(self.tgtInfo[TGT_PATH_KEY]): return True
        backupzip = self.tgtInfo[TGT_BACK_KEY]
        if backupzip and os.path.exists(backupzip):
            tgtDir = os.path.dirname(self.tgtInfo[TGT_PATH_KEY])
            if not os.path.exists(tgtDir): 
                os.mkdir(tgtDir)
            with zipfile.ZipFile(backupzip, 'r') as zipobj:
                zipobj.extractall(tgtDir)
            pass
        else:
            print("Target backup file is not exist: %s" %str(backupzip))

#-----------------------------------------------------------------------------
    def restartTgtProgram(self):
        """ restart the protect target program if it is not running 
        """
        
        filePath = self.tgtInfo[TGT_PATH_KEY]
        print("Start program: %s" %str(filePath))
        if os.path.exists(filePath):
            cmd = self.tgtInfo[TGT_EXE_KEY]
            print(cmd)
            tgtProcess = subprocess.Popen(cmd, start_new_session=True)
            self.tgtPid = tgtProcess.pid
            # record the process ID.
            try:
                with open(self.rcdFile, 'w') as fh:
                    processInfo = ';'.join((str(self.ownPid), str(self.tgtPid))) if self.ownPIdx==0 else ';'.join((str(self.tgtPid), str(self.ownPid)))
                    fh.write(processInfo)
            except Exception as err:
                print("Record process ID error: %s" %str(err))
        return True if psutil.pid_exists(self.tgtPid) else False

#-----------------------------------------------------------------------------
    def getCrtInfo(self):
        """ Get the current protector information."""
        infoDict = {
            'ownPid':   self.ownPid, 
            'ownPidx' : self.ownPIdx,
            'tgtFile':  self.tgtInfo[TGT_PATH_KEY],
            'tgtPid':   self.tgtPid,
            'tgtPIdx':  self.tgtInfo[TGT_RIDX_KEY],
            'tgtRun':   psutil.pid_exists(self.tgtPid),
        }
        return infoDict
    def stop(self):
        self.termate = True

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
def main():
    print("Current working directory is : %s" % os.getcwd())
    dirpath = os.path.dirname(__file__)
    print("Current source code location : %s" % dirpath)
    tgtFile = os.path.join(dirpath, 'malware1.py')
    rcdFile = os.path.join(dirpath, 'rcd.txt')
    ownIdx = 1
    targetInfo = {
        'path': tgtFile,    # target file path.
         # target file exeuction cmd
        'execution': 'python C:\\Works\\NCL\\Project\\Malware_Repo\\src\\processWatchDog\\malware1.py',  
        'backup': 'C:\\User\\test\test.zip', # target program zip file
        'rcdIdx': 1 # configured id in record file.
    }
    protector = processWatchdog(targetInfo, rcdFile, idx=ownIdx)
    protector.start()

#-----------------------------------------------------------------------------
if __name__ == "__main__":
    main()