#-----------------------------------------------------------------------------
# Name:        c2DataManager.py
#
# Purpose:     Data manager class used to manage all the linked program process 
#              the data submitted from the malware.
#              
# Author:      Yuancheng Liu 
#
# Version:     v_0.2
# Created:     2023/01/11
# Copyright:   Copyright (c) 2022 LiuYuancheng
# License:     MIT License   
#-----------------------------------------------------------------------------

import json
from datetime import datetime
from collections import OrderedDict
from copy import deepcopy

import c2HubGlobal as gv
import c2MwUtils

SCH_ID_PREFIX = 'Emu'

# Define all the task state flag here: 
TASK_P_FLG = 0  # task pending flag
TASK_F_FLG = 1  # task finish flag
TASK_A_FLG = 2  # task accept flag
TASK_E_FLG = 3  # task error flag

# Define all class here:
#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
class malwareRecoder(object):
    """ A object to record the controlled malware's data, YC: Later this module will 
        be replace by backend data base.
    """
    def __init__(self, idx, id, ipaddress, tasksList=None):
        """ Init example :
            malwarercd = malwareRecoder( 0 , 'test', '127.0.0.1')
            Args:
                idx (int): record index in the data manager.
                id (str): malware unique ID.
                ipaddress (str): malware ip address
                tasksList (_type_, optional): _description_. Defaults to None.
                - One task dict examlpe:
                {
                    'taskID': 1,
                    'taskType': 'upload',
                    'StartT': None,
                    'repeat': 1,
                    'ExPerT': 0,
                    'taskData': [os.path.join(dirpath, "update_installer.zip")]
                },
        """
        self.idx = idx
        self.uniqID = str(id)
        self.ipaddres = ipaddress
        self.lastUpdateT = None
        self.connected = True
        self.tasksList = [] if tasksList is None else tasksList
        self.taskCountDict = self._initTasksInfo()
        self.updateTime()
        self._initTasksInfo()
        gv.gDebugPrint("Malware [%s] recorder obj Inited." %str(self.uniqID), logType=gv.LOG_INFO)

    #-----------------------------------------------------------------------------
    def _initTasksInfo(self):
        """ Create the task summary dict and add the tast state in the tasks list."""
        taskCountDict = {
            'total':    len(self.tasksList),
            'finish':   0,
            'accept':  len(self.tasksList),
            'pending':  0,
            'error':    0,
            'deactive': 0
        }
        # add the record task state in the task list.
        for i in range(taskCountDict['total']):
            self.tasksList[i]['state'] = TASK_A_FLG if i==0 else TASK_P_FLG
        return taskCountDict 

    def addNewTask(self, taskType, taskData):
        """ Add a new task to the task list. """
        taskInfo = {
            'taskID': len(self.tasksList),
            'taskType': taskType,
            'StartT': None,
            'repeat': 1,
            'ExPerT': 0,
            'taskData': taskData,
            'state': TASK_P_FLG
        }
        self.tasksList.append(taskInfo)
        self.taskCountDict['total'] += 1
        self.taskCountDict['pending'] += 1

    def getTaskList(self):
        return self.tasksList

    #-----------------------------------------------------------------------------
    def getOwnInfo(self, taskContFlg=True):
        """ Get the connector's info. 
            Args:
                taskContFlg (bool, optional): flag to indentify whether return the task info. 
                Defaults to True.
            Returns:
                json: _description_
        """
        infoDict = {
            'idx':self.idx,
            'id': self.uniqID,
            'ipAddr':   self.ipaddres,
            'connected': self.connected,
            'updateT': self.lastUpdateT.strftime('%Y-%m-%d %H:%M:%S')
        }
        if taskContFlg:
            infoDict.update(self.taskCountDict)
        return infoDict

    #-----------------------------------------------------------------------------
    def updateRegisterT(self):
        if len(self.tasksList) > 0:
            self.tasksList[0]['StartT'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    def updateTaskRcd(self, taskList):
        for i, task in enumerate(self.tasksList):
            for taskDict in taskList:
                if task['taskID'] == taskDict['taskID']:
                    self.tasksList[i]['state'] = taskDict['state']
                    self.tasksList[i]['StartT'] = taskDict['Time']
                    break

    def updateTime(self):
        self.lastUpdateT = datetime.now()

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
class DataManager(object):
    """ The data manager is the module contents all the malware record obj and 
        control all the data display on the web.
    """
    def __init__(self, parent) -> None:
        self.idCount = 0
        # malware data record dict.
        self.malwareRcdDict = OrderedDict()
        
    #-----------------------------------------------------------------------------
    def addMalware(self, malwareID, ipaddres, taskList=[]):
        if str(malwareID) in self.malwareRcdDict.keys():
            gv.gDebugPrint("Malware ID: %s is already in record" %str(malwareID), 
                           prt=True, logType=gv.LOG_INFO)
            self.malwareRcdDict.updateRegisterT()
            return 
        else:
            self.malwareRcdDict[str(malwareID)] = c2MwUtils.mvServerRcd(self.idCount, malwareID, ipaddres, 
                                                                 taskList=taskList)
            self.idCount += 1

    def addTaskToMalware(self, malwareIdx, taskType, taskdata):
        malwareIdx = int(malwareIdx)
        malwareIdList = list(self.malwareRcdDict.keys())
        if 0 <= malwareIdx <= len(malwareIdList):
            malwareID = malwareIdList[malwareIdx]
            malwareRcdObj = self.malwareRcdDict[malwareID]
            malwareRcdObj.addNewTask(taskType, taskdata)

#-----------------------------------------------------------------------------
    def buildPeerInfoDict(self, peerIdx):
        """ Build the peer all information dictionary based on the input peer ID.
        Args:
            peerId (_type_): _description_

        Returns:
            _type_: _description_
        """
        peerIdx = int(peerIdx)
        if peerIdx >= len(self.malwareRcdDict.keys()): return None
        peerId = list(self.malwareRcdDict.keys())[peerIdx]
        recordObj = self.malwareRcdDict[peerId]
        recordData = recordObj.getRcdInfo()
        tasksData = recordObj.getTaskList()
        peerInfoDict = {
            "idx": peerIdx,
            "name": peerId,
            "connected" : recordData['connected'],
            "updateT"   : recordData['updateT'],
            "defaultTasks" : tasksData,
        }
        return peerInfoDict

    #-----------------------------------------------------------------------------
    def handleRequest(self, reqDict):
        reqDict = dict(reqDict)
        id = reqDict['id']
        data = reqDict['data']
        if reqDict[c2MwUtils.ACT_KEY] == c2MwUtils.RIG_FLG:
            ipaddr = data['ipaddr']
            taskList = data['tasks']
            self.addMalware(id, ipaddr, taskList=taskList)
            return {c2MwUtils.ACT_KEY: c2MwUtils.RIG_FLG,
                    'state':            c2MwUtils.TASK_F_FLG}
        elif reqDict['action'] == c2MwUtils.UPLOAD_FLG:
            # send the upload file request accept flag
            return {c2MwUtils.UPLOAD_FLG: c2MwUtils.ACCEPT_FLG}
        elif reqDict['action'] == c2MwUtils.DOWNLOAD_FLG:
            return {c2MwUtils.DOWNLOAD_FLG: c2MwUtils.ACCEPT_FLG}
        elif reqDict['action'] == c2MwUtils.RPT_FLG:
            self.updateTaskState(id, data)
            return {c2MwUtils.RPT_FLG: c2MwUtils.ACCEPT_FLG}
        elif reqDict['action'] == 'getTask':
            mvObj = self.malwareRcdDict[id]
            taskList = mvObj.getTaskList(taskType=c2MwUtils.TASK_P_FLG)
            if len(taskList) > 0:
                task = taskList[0]
                tskId = task['taskID']
                mvObj.setTaskState(tskId, state=c2MwUtils.TASK_A_FLG)
                return {'task': task}
            return None


    #-----------------------------------------------------------------------------
    def getMalwaresInfo(self, malwareIDList=None):
        """ Return a list of malware summary information."""
        if malwareIDList is None: malwareIDList = self.malwareRcdDict.keys() 
        return [self.getMalwareDetail(pName) for pName in malwareIDList] 

    def getMalwareDetail(self, peerName):
        if peerName in self.malwareRcdDict.keys():
            return self.malwareRcdDict[peerName].getRcdInfo()
        return {}

    def updateTaskState(self, malId, reportInfo):
        if malId in self.malwareRcdDict.keys():
            self.malwareRcdDict[malId].updateTaskRcd(reportInfo)

#-----------------------------------------------------------------------------
    def changeTaskState(self, peerName, jobID, action):
        if peerName in self.connectorDict.keys():
            self.connectorDict[peerName].changeTask(jobID, action)

#-----------------------------------------------------------------------------
    def getOnePeerDetail(self, peerName):
        if peerName in self.connectorDict.keys():
            return self.connectorDict[peerName].getRcdInfo()
        return {}


