#-----------------------------------------------------------------------------
# Name:        dataManage.py
#
# Purpose:     Data manager class used to provide specific data fetch and process 
#              functions and init the local data storage.
#              
# Author:      Yuancheng Liu 
#
# Version:     v_0.2
# Created:     2023/01/11
# Copyright:   
# License:     
#-----------------------------------------------------------------------------

import json
from datetime import datetime
from collections import OrderedDict
from copy import deepcopy

import c2HubGlobal as gv
import Log


SCH_ID_PREFIX = 'Emu'


# Define all class here:
#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
class malwareRecoder(object):
    """ A object to record the controlled malware's data 
    """
    def __init__(self, idx, id, ipaddress, taskDict=None):
        self.idx = idx
        self.uniqID = id
        self.ipaddres = ipaddress
        self.lastUpdateT = None
        self.taskFlg = False
        self.taskDict = taskDict
        self.taskCountDict = {
            'total': 0,
            'finish': 0,
            'running':0,
            'pending': 0,
            'error': 0,
            'deactive': 0
        }
        self.updateTime()
        gv.gDebugPrint("Peer Connector Inited.", logType=gv.LOG_INFO)

    def tasksList(self):
        return self.taskDict
    
    def updateTime(self):
        self.lastUpdateT = datetime.now()

    #-----------------------------------------------------------------------------
    def getOwnInfo(self, taskContFlg=True):
        """ Get the connector's info. 
            Args:
                taskContFlg (bool, optional): flag to indentify whether return the task info. 
                Defaults to True.
            Returns:
                json: _description_
        """
        infoDict = {
            'idx':self.idx,
            'id': self.uniqID,
            'ipAddr':   self.ipaddres,
            'connected': self.taskFlg
        }
        if taskContFlg:
            infoDict.update(self.taskCountDict)
        infoDict['updateT'] = self.lastUpdateT.strftime('%Y-%m-%d %H:%M:%S')
        return infoDict

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
class DataManager(object):
    """ The data manager is the module contents all the connectors obj and control 
        all the data display on the web.
    """
    def __init__(self, parent) -> None:
        self.idCount = 0 
        self.malwareInfoDict = OrderedDict()
        
        self.connectorDict = {} # the connector dict.
        self.schedulerDetailDict = {}   # dictionary to store the schduler's detail information.

    def addMalware(self, malwareID, ipaddres):
        if str(malwareID) in self.malwareInfoDict.keys():
            gv.gDebugPrint("Malware ID: %s is already in record" %str(malwareID), prt=True, logType=gv.LOG_INFO)
            return 
        else:
            self.malwareInfoDict[str(malwareID)] = malwareRecoder(self.idCount, malwareID, ipaddres)
            self.idCount += 1

    def getMalwaresInfo(self, malwareIDList=None):
        if malwareIDList is None: malwareIDList = self.malwareInfoDict.keys() 
        return [self.getMalwareDetail(pName) for pName in malwareIDList] 

    def handleRequest(self, reqDict):
        reqDict = dict(reqDict)
        if reqDict['action'] == 'register':
            id = reqDict['id']
            ipaddr = reqDict['data']['ipaddr']
            self.addMalware(id, ipaddr)
            return {'action': 'register', 'state': 'ok'}
        elif reqDict['action'] == '':
            pass

#-----------------------------------------------------------------------------
    def getMalwareDetail(self, peerName):
        if peerName in self.malwareInfoDict.keys():
            return self.malwareInfoDict[peerName].getOwnInfo()
        return {}

#-----------------------------------------------------------------------------
    def changeTaskState(self, peerName, jobID, action):
        if peerName in self.connectorDict.keys():
            self.connectorDict[peerName].changeTask(jobID, action)

#-----------------------------------------------------------------------------
    def removeSchedulerPeer(self, peerName):
        """ Remove the scheduler based on the input peer name."""
        if peerName in self.connectorDict.keys():
            self.connectorDict[peerName].close()
            self.connectorDict[peerName] = None
            self.connectorDict.pop(peerName)
            return True  
        return False

#-----------------------------------------------------------------------------
    def getOnePeerDetail(self, peerName):
        if peerName in self.connectorDict.keys():
            return self.connectorDict[peerName].getOwnInfo()
        return {}

#-----------------------------------------------------------------------------
    def getPeersInfo(self, NameList=None):
        if NameList is None: NameList = self.connectorDict.keys() 
        return [self.getOnePeerDetail(pName) for pName in NameList] 

#-----------------------------------------------------------------------------
    def getPeerConnInfo(self, peerName):
        #print(self.connectorDict.keys())
        if peerName in self.connectorDict.keys():
            return self.connectorDict[peerName].getConnState()
        return None

#-----------------------------------------------------------------------------
    def getPeerTaskInfo(self, peerName, infoType):
        if peerName in self.connectorDict.keys():
            return self.connectorDict[peerName].getJobsState(infoType)
        return None
            
#-----------------------------------------------------------------------------
    def getPeerName(self, id):
        if str(id) in self.schedulerIds.keys():
            return self.schedulerIds[str(id)]
        return None

# Define all general function and test case here:
#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------

def buildPeerInfoDict(peerId):
    """ Build the peer all information dictionary based on the input peer ID.
    Args:
        peerId (_type_): _description_

    Returns:
        _type_: _description_
    """
    peerName = gv.iDataMgr.getPeerName(peerId)
    peerInfoDict = {
        "name": peerName,
        "connected" : False,
        "updateT"   : None,
        "daily"     : [],
        "random"    : [],
        "weekly"    : []
    }
    result = gv.iDataMgr.getPeerConnInfo(peerName)
    taskInfoDict = gv.iDataMgr.getPeerTaskInfo(peerName, 'all')
    if result: peerInfoDict['connected'] = result[0]
    if result: peerInfoDict['updateT'] = result[1]
    if taskInfoDict and taskInfoDict['daily']: peerInfoDict['daily'] = taskInfoDict['daily']
    if taskInfoDict and taskInfoDict['random']: peerInfoDict['random'] = taskInfoDict['random']
    if taskInfoDict and taskInfoDict['weekly']: peerInfoDict['weekly'] = taskInfoDict['weekly']
    return peerInfoDict
